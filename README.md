# Physically Based Rendering. Path Tracing implementation in C++

Path tracing is a complex way to compute physically based lighting.

Well-chosen **[BRDF](https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function)** make this approach physically correct.

![4k resolution](illustrations/small_light_50ksamples.png)

# Foundation

## Rendering equation

Rendering equation describes irradiance of the surface for a given point: $$L_\Theta \left(\vec{X}, \omega_\Theta \right) = L_e\left( \vec{X}, \omega_\Theta \right) + \int\limits_\Omega f_r\left( \vec{X}, \omega_\Psi, \omega_\Theta \right) L_\Psi \left(\vec{X}, \omega_\Psi \right) \left( \vec{\Psi} \cdot \vec{N} \right) d\omega_\Psi$$

Symbols in this equation mean:
+ $\vec{\Psi}$ — incoming light direction
+ $\vec{\Theta}$ — outgoing light direction
+ $\vec{X}$ — point on surface
+ $d\omega_\Psi$ — differential of solid angle
+ $\Omega$ — hemisphere of all incoming directions for light onto surface where $\left( \vec{\Psi} \cdot \vec{N} \right) > 0$
+ $L_\Theta$ — irradiance of point on surface
+ $L_\Psi$ — radiance from light incoming from direction $\vec{\Psi}$
+ $L_e$ — light emitted from point on surface
Consider all vectors are unit.

## Monte Carlo integration

[Monte Carlo integration](https://en.wikipedia.org/wiki/Monte_Carlo_integration) tells us that integral with limits $a$ and $b$ can be computed as an average of $N$ samples multipled by length of segment $\left(a, b\right)$:

$$\int\limits_a^b f(x)dx = \left(b - a\right)\dfrac{1}{N} \sum\limits_{i=1}^{N} f(x)$$

Computers can only approximate rendering equation integral. I used Monte Carlo technique to estimate light emission value.

## BRDF

BRDF stands for Bidirectional reflectance distribution function $f_r$. It tells us what how light is being reflected of a surface. According to conservation of energy law we assume that:

$$\rho = \int\limits_\Omega f_r\left( \vec{X}, \omega_\Psi, \omega_\Theta \right) \left( \vec{\Psi} \cdot \vec{N} \right) d\omega_\Psi <= 1$$

$\rho$ stands for albedo, i.e. whiteness of a surface, which is amount of light being reflected of a surface.

### Lambertian BRDF

Lambertian BRDF describes diffuse lighting and rough surfaces. Surface is rough when incoming light is being reflected in any direction in unit hemisphere along surface normal, i.e. $f_r\left( \vec{X}, \omega_\Psi, \omega_\Theta \right) = const$. 

Let's derive formula for $f_{Lambertian}$. Let's consider that material of surface is known that, so we know its albedo.

$$
\rho = \int\limits_\Omega f_{Lambertian} \left( \vec{\Psi} \cdot \vec{N} \right) d\omega_\Psi \implies
f_{Lambertian} = \dfrac{\rho}{\int\limits_\Omega \left( \vec{\Psi} \cdot \vec{N} \right) d\omega_\Psi} \\
$$

Lets use $\phi$ and $\theta$ for spherical coordinates in unit hemisphere $\Omega$, so $d\omega_\Psi$ = $\sin\left( \theta \right) d\theta d\phi$.

$$
\int\limits_\Omega \left( \vec{\Psi} \cdot \vec{N} \right) d\omega_\Psi = \int\limits_{\phi=0}^{2\pi} \int\limits_{\theta=0}^{\frac{\pi}{2}} \sin\left( \theta \right) \cos\left( \theta \right) d\theta d\phi = \\ = \int\limits_{\phi=0}^{2\pi} d\phi \times \dfrac{1}{2} \int\limits_{\theta=0}^{\frac{\pi}{2}} \sin\left( 2\theta \right) d\theta 
$$

# Build

For successful build you need only C++ compiler with supported C++20 standard.

```bash
git clone https://github.com/ivan0sokin/path-tracing-cpp/
cd path-tracing-cpp
cmake --build .
```

# Documentation
The documentation is generated by Doxygen and [can be found here](https://ivan0sokin.github.io/path-tracing-cpp/).